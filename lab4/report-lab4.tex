\documentclass[12pt]{article}

% Специальный шрифт, чтобы лучше читалось
\usepackage{libertine}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{titlesec}

\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection.}{0.3em}{}

\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection.}{0.3em}{}

\titlespacing{\section}{0pt}{*2}{*2}
\titlespacing{\subsection}{0pt}{*1}{*1}
\titlespacing{\subsubsection}{0pt}{*0}{*0}
\usepackage{listings}
\lstloadlanguages{Lisp}
\lstset{extendedchars=false,
	breaklines=true,
	breakatwhitespace=true,
    escapechar=\%,
	keepspaces=true,
	tabsize=8
}
\begin{document}

\section*{Отчет по лабораторной работе № 4 \\
по курсу \guillemotleft Функциональное программирование\guillemotright}
\begin{flushright}
Студент группы М8О-307-19 МАИ \textit{Инютин Максим Андреевич}, \textnumero 10 по списку \\
\makebox[7cm]{Контакты: {\tt mainyutin@gmail.com} \hfill} \\
\makebox[7cm]{Работа выполнена: 20.05.2022 \hfill} \\
\ \\
Преподаватель: Иванов Дмитрий Анатольевич, доц. каф. 806 \\
\makebox[7cm]{Отчет сдан: \hfill} \\
\makebox[7cm]{Итоговая оценка: \hfill} \\
\makebox[7cm]{Подпись преподавателя: \hfill} \\

\end{flushright}

\section{Тема работы}
Знаки и строки.

\section{Цель работы}
Научиться работать с литерами (знаками) и строками при помощи функций обработки строк и общих функций работы с последовательностями.

\section{Задание (вариант № 4.44)}
Запрограммировать на языке Коммон Лисп функцию с двумя параметрами:

\begin{itemize}
    \item char-bag --- список знаков,
    \item text --- текст.
\end{itemize}

Функция должна вернуть преобразованный текст, во всех предложениях которого все слова <<обтёсаны>>, т.е. в них с обоих концов, удалены знаки, упомянутые в char-bag.

\section{Оборудование студента}
Процессор Intel Core i7-9750H (12) @ 4.5GHz, память: 32 Gb, разрядность системы: 64.

\section{Программное обеспечение}
ОС Ubuntu 20.04.4 LTS, комилятор GNU CLISP 2.49.92, текстовый редактор Atom 1.58.0

\pagebreak
\section{Идея, метод, алгоритм}
Текстом называется список предложений. Предложение представляется строкой и состоит из слов, разделённых пробелами, знаками горизонтальной табуляции или перевода строки. Возможно больше одного пробела между двумя словами.

Функция text-trim отделяет голову текста, обрабатывает предложение и добавляет его в результирующий список. Так результат будет в обратном порядке, поэтому нужно делать реверс. Для обработки предложений я разбиваю строку на слова и обтёсываю их. Результат --- конкатенация обтёсанных слов и тех же разделителей, что и в исходной строке.

Для обтёсывания я использую встроенную функцию string-trim. Её сложноть неизвестна, но я бы реализовал её так: сохранял бы все символы в хэш-таблицу, удалял символы с конца, пока они в таблице, сделал бы реверс строки и повторил процедуру, снова реверс строки. Если считать сложность обращения к хэш-таблице $O(1)$, то функция имела бы сложность $O(|s|)$ для строки $s$. Буду считать, что она действительно такая. Реверс списка тоже имеет линейную сложность, поэтому асимптотика алгоритма $O(n + \sum_{i=1}^n{|s_i|})$, где $n$ --- количество предложений в тексте, а $s_i$ --- $i$ предложение.

\section{Сценарий выполнения работы}

\section{Распечатка программы и её результаты}

\subsection{Исходный код}
\lstinputlisting{./lab4.lisp}

\pagebreak
\subsection{Результаты работы}
\lstinputlisting{./log4.txt}

\pagebreak
\section{Дневник отладки}
\begin{tabular}{|p{50pt}|p{140pt}|p{140pt}|p{80pt}|}
\hline
Дата & Событие & Действие по исправлению & Примечание \\
\hline
\end{tabular}

\section{Замечания автора по существу работы}

Сложность полученного решения $O(n + \sum_{i=1}^n{|s_i|})$. Добиться лучшей асимптотики нельзя, так как сами данные имеют такую же размерность. Можно попробовать уменьшить константу за счёт написания своего string-trim и использования другой структуры данных для хранения набора удаляемых символов.

\section{Выводы}
Я познакомился со строками и литерами в Common Lisp. Очень приятно использовать высокоуровневые функции, например subseq, встроенные в язык. Чем-то напоминает Python, в котором так же легко работать со строками.

\end{document}
